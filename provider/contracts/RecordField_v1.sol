pragma solidity ^0.4.8;

import '../../gmo/contracts/VersionField.sol';
import './Record.sol';

contract RecordField_v1 is VersionField, Record {
    struct Field {
        bool isCreated;
        bool isRemoved;
        mapping (address => mapping(bytes32 => bool)) allowCnsContracts; //address=>(contractname=>isAllowGroup);
        address doctor; // who create Record
        address historyId; // historyId is patient address
        bytes32 objectId; // DataObject of description
    }

    mapping(bytes32 => Field) public fields; // generated by admin client

    function RecordField_v1(ContractNameService _cns) VersionField(_cns, CONTRACT_NAME) {}

    /* OVERRIDE */
    function existIdAtCurrentVersion(bytes32 _id) constant returns (bool) {
        return fields[_id].isCreated;
    }

    /* OVERRIDE */
    function setDefault(bytes32 _id) private {
        fields[_id] = Field({isCreated:true, isRemoved:false, doctor:0, historyId:0, objectId:0});
    }

    function allowCnsContracts(bytes32 _id, address _cns, bytes32 _contractName) constant returns (bool) {
        return fields[_id].allowCnsContracts[_cns][_contractName];
    }

    function setAllowCnsContract(bytes32 _id, address _cns, bytes32 _contractName, bool _isAdded) onlyByNextVersionOrVersionLogic {
        prepare(_id);
        fields[_id].allowCnsContracts[_cns][_contractName] = _isAdded;
    }

    function isAllowCnsContract(address _cns, bytes32 _contractName, bytes32 _id) constant returns (bool) {
        if (shouldReturnDefault(_id)) return false;
        return fields[_id].allowCnsContracts[_cns][_contractName];
    }

    /* ----------- create / remove Record----------------- */

    function create(address _doctorAddr, bytes32 _id, address _historyId, bytes32 _objectId) onlyByNextVersionOrVersionLogic {
        if(exist(_id)) throw;
        fields[_id] = Field({isCreated:true, isRemoved:false, doctor:_doctorAddr, historyId:_historyId, objectId:_objectId});
    }

    function remove(bytes32 _id) onlyByNextVersionOrVersionLogic {
        if(!exist(_id)) throw;
        fields[_id].isRemoved = true;
    }

    /* ----------- getters and setters----------------- */

    function getIsCreated(bytes32 _id) constant returns (bool) {
        if(shouldReturnDefault(_id)) return true;
        return fields[_id].isCreated;
    }

    function getIsRemoved(bytes32 _id) constant returns (bool) {
        if(shouldReturnDefault(_id)) return false;
        return fields[_id].isRemoved;
    }

    function getDoctor(bytes32 _id) constant returns (address) {
        if(shouldReturnDefault(_id)) return 0;
        return fields[_id].doctor;
    }

    function getHistory(bytes32 _id) constant returns (address) {
        if(shouldReturnDefault(_id)) return 0;
        return fields[_id].historyId;
    }

    function getObjectId(bytes32 _id) constant returns (bytes32) {
        if(shouldReturnDefault(_id)) return 0;
        return fields[_id].objectId;
    }

    function setIsCreated(bytes32 _id, bool _isCreated) onlyByNextVersionOrVersionLogic {
        prepare(_id);
        fields[_id].isCreated = _isCreated;
    }

    function setIsRemoved(bytes32 _id, bool _isRemoved) onlyByNextVersionOrVersionLogic {
        prepare(_id);
        fields[_id].isRemoved = _isRemoved;
    }

    function setDoctor(bytes32 _id, address _doctorAddr) onlyByNextVersionOrVersionLogic {
        prepare(_id);
        fields[_id].doctor = _doctorAddr;
    }

    function setHistory(bytes32 _id, address _historyId) onlyByNextVersionOrVersionLogic {
        prepare(_id);
        fields[_id].historyId = _historyId;
    }

    function setObjectId(bytes32 _id, bytes32 _objectId) onlyByNextVersionOrVersionLogic {
        prepare(_id);
        fields[_id].objectId = _objectId;
    }
}
